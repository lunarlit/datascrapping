# Stage 1 - 정적 수집과 동적 수집 비교

이번 스테이지에서는 기존에 배우던 방식인 정적 수집과 오늘 사용할 동적 수집을 비교해보고 어떤 상황에 어떤 방식을 써야 하는지 배워봅니다.

얼핏 봐서는 브라우저를 사용하는 수집이 만능이라 정적 수집을 쓸 필요가 없어보이지만 정적 수집은 속도가 매우 빠르기 때문에 가능하면 사용하는 편이 좋습니다.



## 정적 수집을 사용할 수 있는 경우

![](../.gitbook/assets/image%20%28189%29.png)

가장 처음 데이터수집을 해보았던 네이버 TV TOP 100 페이지입니다. 이 페이지의 특징은 한 페이지 안에 모든 데이터가 다 담겨있다는 것입니다.

제일 먼저 다룬만큼 가장 쉬운 형태라고 할 수 있겠습니다.



![](../.gitbook/assets/image%20%28109%29.png)

여러 페이지를 수집하는 예제에서 수집해 본 네이버 뉴스와 과제로 나왔던 Hashcode라는 서비스입니다. 이 서비스들은 여러 페이지를 이동하며 수집해야 했지만 각 페이지마다 주소\(정확히는 요청값\)가 달라지는 모습을 보였습니다.

따라서 단순히 주소의 요청값만 잘 바꿔준다면 첫 번째 형태를 여러 번 반복하는 것과 마찬가지입니다.

이렇게 정적 수집이 가능한 페이지의 특징은

1. 별다른 절차없이 주소로 바로 접속해도 데이터를 볼 수 있다.
2. 새로고침하지 않으면 페이지 안의 데이터가 변하지 않는다. \(데이터가 정적이다.\)

간단하게는 이 두가지로 정리해볼 수 있겠습니다.  
\(이 두 가지를 만족하나 정적 수집이 불가능한 경우도 없지는 않습니다.\)



## 정적 수집을 사용할 수 없는 경우

![](../.gitbook/assets/image%20%2818%29.png)

네이버 메일함은 바로 접속할 수 없고 반드시 로그인을 거쳐야 합니다.

로그인 후 메일함의 주소를 복사하여 로그아웃된 상태에서 접속해보아도 왼쪽의 로그인 안내창으로 이어집니다.



![](../.gitbook/assets/image%20%28167%29.png)

굉장히 독특한 경우인데 메인 페이지를 통하지 않고 바로 접속하면 이용할 수 없는 페이지입니다.

파이썬 코드에서 메인 페이지를 접속했다가 해당 페이지로 접속해보아도, 두 접속은 이어지는 것이 아니라 별개의 요청이기 때문에 소용이 없습니다.



![](../.gitbook/assets/image%20%28216%29.png)

최근의 발달한 웹 기술을 이용하면 새로고침을 하지 않고도 데이터를 추가로 로딩할 수가 있습니다.

좌측의 사진 목록은 스크롤이 끝까지 도달하려하면 사진을 더 불러옵니다. 우측의 갤러리 뷰는 화살표를 누르면 새로운 사진이 계속 로딩됩니다.

이런 동적 로딩 데이터들은 최초 한 번밖에 얻어올 수 없는 정적 수집으로는 도달이 불가능합니다.



위와 같이 같은 주소를 사용해 접속해도 상황에 따라 데이터를 볼 수 없거나 다른 데이터가 나오는 페이지들은 기존 방식으로 수집할 수가 없습니다.



## 정적 수집과 동적 수집의 비교



기존에 배운 방식은 아래와 같이 주소에서 HTML 소스를 가져오도록 요청합니다.

```python
requests.get('https://tv.naver.com/r/')
raw = req.text
html = BeautifulSoup(raw, 'html.parser')
```

이를 어느 상황에서나 같은 주소에서 변하지 않는 데이터를 기대할 수 있다는 의미에서 정적\(static\) 수집이라 부릅니다.



Stage 2부터 배워볼 수집 방식은 아래와 같이 실제 브라우저를 도구로 이용합니다.

![](../.gitbook/assets/image%20%28171%29.png)

단순히 HTML 소스를 요청할 뿐만 아니라 입력, 클릭 등 실제 브라우저를 사용할 때 하는 행동들도 수행할 수 있다는 의미에서 동적\(dynamic\) 수집이라 부릅니다.

위에서 봤던 예시들처럼 같은 주소를 가지고도 상황에 따라 데이터가 변하는 동적 페이지를 수집한다는 의미도 가지고 있습니다.



![](../.gitbook/assets/image%20%28150%29.png)

정적 수집과 동적 수집의 차이를 간단히 정리한 비교표입니다.

정적 수집은 한 번 주소를 통해 요청하고 결과를 받는 것으로 끝입니다. 로그인 상태를 유지하는 등 연속적인 작업을 수행할 수 없습니다. 반면 동적 수집은 브라우저를 실제로 사용하기 때문에 브라우저가 꺼지지 않는 한 이전에 수행한 작업의 영향을 유지할 수 있습니다.

또한 정적 수집은 위의 예제에서 보듯 웹에 존재하는 다양한 서비스를 모두 수집하기엔 한계가 있습니다. 따라서 필연적으로 동적 수집을 활용해야 합니다. 정적 수집을 먼저 배운 이유는 과정이 단순하여 이해하기 쉽기 때문입니다.

정적 수집은 단점밖에 없어보이지만 꼭 사용해야 할 이유가 있습니다. HTML 결과를 받아 브라우저에 그려주는 과정이 생략되기 때문에 속도가 매우 빠르다는 것입니다. 따라서 정적 수집은 사용이 제한적이지만 가능한 경우 최대한 사용해주는 것이 좋습니다.

그러면 다음 스테이지에서 동적 수집을 가능케하는 selenium 라이브러리에 대해 배워보겠습니다.





























# Stage 1 - 일단 가장 간단하게 저장해보자

첫번째 스테이지에서는 간단한 문법으로 쉽게 데이터를 저장할 수 있는 방법에 대해 알아봅니다.

사용이 간단한만큼 저장된 데이터도 복잡한 형태를 가지기 힘든 txt나 csv파일이 되지만, 닭 잡는데 소 잡는 칼을 쓸 필요가 없듯 간단한 형태로 저장하는 경우도 필요할 때가 있습니다.

또한 파이썬이 외부 파일을 다루는 구조에 대해 이해하기 쉬우니 먼저 이 방법으로 시작해 보겠습니다.

## 파이썬코드로 파일 열기

```python
f = open('test.txt', 'w')
```

시작부터 코드부터 나와 당황하셨겠지만, 위의 한 줄만 실행시켜도 파이썬은 외부 파일을 열게 됩니다.

![](../.gitbook/assets/image%20%2815%29.png)

위 코드를 실행시키면 실행한 폴더에 test.txt가 생성됩니다.

open\( \) 함수에 전달되는 두 매개변수 중 첫번째는 당연히 파일의 이름이고, 두번째는 파일을 다룰 모드입니다.

![](../.gitbook/assets/image%20%28228%29.png)

이 모드의 값에 따라 위와 같이 파일에 대해 실행할 수 있는 기능이 다릅니다.

먼저 쓰기 모드를 사용해 파일 내용을 작성해보겠습니다.

```python
f = open('test.txt', 'w')

f.write("hello world!")
f.close()
```

open의 결과값을 변수 f에 집어넣고 있습니다.

이제 f는 파일 클래스의 변수가 되어 여러 함수를 통해 test.txt 를 컨트롤할 수 있습니다.

.write\( \) 함수는 매개변수로 전달된 문자열을 파일에 쓰는 역할을 하고,

.close\( \) 함수는 열었던 파일을 닫아 더 이상 컨트롤할 수 없게 만듭니다.

사용이 끝난 파일은 꼭 .close\( \) 를 실행하여 권한을 반납하여야 합니다.

![](../.gitbook/assets/image%20%28208%29.png)

위 코드를 실행하고 test.txt를 열어보면, hello world! 가 성공적으로 작성된 것을 볼 수 있습니다.



```python
f = open('test.txt', 'a')

f.write("hello world!")
f.close()
```

다음으로 위 코드를 바꾸어 파일을 추가 모드 \(append의 'a'\) 로 열어 내용을 작성해 보겠습니다.

![](../.gitbook/assets/image%20%28162%29.png)

이 코드를 실행하고 test.txt를 열어보면, 기존 내용에 새로 작성한 내용이 더해진 것이 보입니다.

이처럼 추가 모드에서는 기존 내용을 그대로 두고 내용을 추가합니다.



![](../.gitbook/assets/image%20%28179%29.png)

읽기 모드를 알아보기에 앞서, test.txt의 내용에 한 줄을 추가해 주세요.



```python
f = open('test.txt', 'r')
lines = f.readlines()

for line in lines:
    print(line)

f.close()
```

읽기 모드를 사용해 파일을 열면, .readlines\( \) 함수를 사용해 내용을 읽어올 수 있습니다.

함수의 결과로 배열을 돌려주는데, 각 요소는 파일의 한 줄입니다.

따라서 위 코드는 다음 결과를 출력합니다.

![](../.gitbook/assets/image%20%286%29.png)



## 수집한 데이터 저장해보기

이제 파일에 간단히 저장하는 방법을 알았으니, 네이버 TV TOP 100으로 돌아가 정렬된 결과를 저장해봅시다.

저장된 Dictionary를 정렬하여 sortedList라는 변수에 넣었을 것입니다.

```python
f = open('test.txt', 'w')
```

먼저 코드 시작지점에 파일을 열어두고



```python
for sortedInfo in sortedList:
    f.write(sortedInfo[0] + ',' + str(sortedInfo[1]['hit']) + '\n')

f.close()
```

정렬 후에 위 코드를 추가하여 결과를 파일에 씁니다.

\( 채널명, 조회수 \n \) 의 형식으로 하나씩 파일에 쓰게 됩니다.

{% hint style="info" %}
\n 은 줄바꿈 문자입니다.

메모장에 직접 쓸 때는 Enter를 눌러 줄을 바꾸지만, 코드 상에서는 이를 표현할 수 없어 대신 '\n' 을 만나면 줄을 바꾸도록 정해져 있습니다.

/ \(슬래시\) 와 헷갈리지 않게 주의하세요!
{% endhint %}

위 코드들을 추가하여 실행시키면 다음과 같은 결과 파일을 얻을 수 있습니다.

![](../.gitbook/assets/image%20%2871%29.png)

잘 저장이 되었습니다. 그런데 메모장은 아무래도 줄이 맞지 않아 데이터를 확인하기 불편하네요. 



혹시 csv라는 파일 형식을 아시나요?

csv는 Comma Seperated Values의 약자로, 쉼표로 구분된 값들을 의미합니다. 

마침 저희가 데이터를 쉼표로 구분하여 저장했는데요.

```python
f = open('test.csv', 'w')
```

파일을 열 때 확장자만 .csv로 바꾸어 다시 실행해 봅시다.



![](../.gitbook/assets/image%20%28153%29.png)

csv 파일은 이처럼 엑셀을 사용해 열 수 있습니다. 

쉼표 부분을 분리 기준으로 인식하여 다른 셀에 값을 집어넣어줍니다.

결과적으로 들어있는 값은 똑같지만 보기가 훨씬 편합니다.  
\(엑셀이 설치되어있지 않으신 분들은 엑셀 뷰어로 확인해주세요!\)



## 파일명 자동 변경

네이버 TV TOP100의 데이터를 매일 수집한다고 해봅시다. 

open\( \) 함수를 이용해 파일을 쓰기 모드로 열면, 기존에 있던 데이터는 모두 사라지는데요.

그렇다고 추가 모드로 열기엔 날짜별로 데이터가 구분되지 않아 불편할 것 같네요. 

![](../.gitbook/assets/image%20%28224%29.png)

대신 수집하는 날짜마다 파일명을 바꾸어 'TOP100\_2018\_06\_28.csv' 와 같이 저장한다면 잘 구분되겠죠?

그런데 실행할 때마다 날짜를 바꿔서 코드에 넣어주어야 한다면 여간 불편한 일이 아닐 것입니다. 

완성된 코드를 계속 수정해야 한다는 것은 설계가 잘못되었다는 말이기도 하구요.



다행히 파이썬에서는 날짜를 확인하고 사용할 수 있는 클래스를 제공합니다.

```python
import datetime

dt = datetime.datetime.now()

print(dt)
```

![](../.gitbook/assets/image%20%28132%29.png)

datetime이라는 클래스를 import하여 다음과 같이 현재 시간을 불러올 수 있습니다.

하지만 이를 그대로 파일명에 사용하기엔 부적합합니다. 

하루에 한 번 수집할 것이기 때문에 날짜까지만 필요하고, ':' 문자는 파일명에 사용할 수 없기 때문입니다.

```python
df = dt.strftime('%Y_%m_%d')

print(df)
```

![](../.gitbook/assets/image%20%2860%29.png)

datetime 클래스의 .strftime\( \) \(**str**ing **f**ormatted **time** 이라는 뜻이겠네요.\) 함수를 사용하면 날짜 데이터를 원하는 형태로 만들 수 있습니다.

![](../.gitbook/assets/image%20%28163%29.png)

.strftime\( \) 함수에 전달되는 형식 문자열은 위와 같은 내용으로 구성됩니다. 

문자열 안의 %Y가 실제 날짜 데이터의 연도 값으로 대체되는 것이죠. 

위 표에 나와있지 않은 \_ 같은 문자는 대체하지 않고 그대로 출력됩니다.

그 결과 우리는 파일명에 사용하고자 하는 2018\_06\_28을 얻을 수 있습니다.

```python
dt = datetime.datetime.now()
filename = 'TOP100_' + dt.strftime("%Y_%m_%d")
f = open(filename + '.csv', 'w')
```

이 문자열 앞에 'TOP100\_' 을 붙여 파일명으로 전달하면, 매일 코드를 수정하지 않고도 데이터를 날려먹지 않고 수집할 수 있습니다!

\(그래도 같은 날짜에 두 번 이상 수집하면 이전 데이터가 날아가겠죠? 

이럴 경우 시간, 분, 초 단위까지 필요에 따라 활용해서 파일명을 변경해야겠습니다.\)